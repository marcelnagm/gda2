<?php


/**
 * Base class that represents a query for the 'tbprofessor' table.
 *
 *
 *
 * This class was autogenerated by Propel 1.6.7 on:
 *
 * Tue Apr 23 17:54:40 2013
 *
 * @method TbprofessorQuery orderByIdPessoa($order = Criteria::ASC) Order by the id_pessoa column
 * @method TbprofessorQuery orderByMatriculaProf($order = Criteria::ASC) Order by the matricula_prof column
 * @method TbprofessorQuery orderBySiape($order = Criteria::ASC) Order by the siape column
 * @method TbprofessorQuery orderByNome($order = Criteria::ASC) Order by the nome column
 * @method TbprofessorQuery orderByCelular($order = Criteria::ASC) Order by the celular column
 * @method TbprofessorQuery orderByFoneResidencial($order = Criteria::ASC) Order by the fone_residencial column
 * @method TbprofessorQuery orderByEmail($order = Criteria::ASC) Order by the email column
 * @method TbprofessorQuery orderByFoto($order = Criteria::ASC) Order by the foto column
 * @method TbprofessorQuery orderByIdNecesEspecial($order = Criteria::ASC) Order by the id_neces_especial column
 * @method TbprofessorQuery orderByCodCurso($order = Criteria::ASC) Order by the cod_curso column
 * @method TbprofessorQuery orderByIdTipoVinculo($order = Criteria::ASC) Order by the id_tipo_vinculo column
 * @method TbprofessorQuery orderByIdFormacao($order = Criteria::ASC) Order by the id_formacao column
 * @method TbprofessorQuery orderByIdProfSit($order = Criteria::ASC) Order by the id_prof_sit column
 * @method TbprofessorQuery orderByIdSetor($order = Criteria::ASC) Order by the id_setor column
 * @method TbprofessorQuery orderByCoordenador($order = Criteria::ASC) Order by the coordenador column
 * @method TbprofessorQuery orderByCreatedAt($order = Criteria::ASC) Order by the created_at column
 * @method TbprofessorQuery orderByUpdatedAt($order = Criteria::ASC) Order by the updated_at column
 * @method TbprofessorQuery orderByCreatedBy($order = Criteria::ASC) Order by the created_by column
 * @method TbprofessorQuery orderByUpdatedBy($order = Criteria::ASC) Order by the updated_by column
 *
 * @method TbprofessorQuery groupByIdPessoa() Group by the id_pessoa column
 * @method TbprofessorQuery groupByMatriculaProf() Group by the matricula_prof column
 * @method TbprofessorQuery groupBySiape() Group by the siape column
 * @method TbprofessorQuery groupByNome() Group by the nome column
 * @method TbprofessorQuery groupByCelular() Group by the celular column
 * @method TbprofessorQuery groupByFoneResidencial() Group by the fone_residencial column
 * @method TbprofessorQuery groupByEmail() Group by the email column
 * @method TbprofessorQuery groupByFoto() Group by the foto column
 * @method TbprofessorQuery groupByIdNecesEspecial() Group by the id_neces_especial column
 * @method TbprofessorQuery groupByCodCurso() Group by the cod_curso column
 * @method TbprofessorQuery groupByIdTipoVinculo() Group by the id_tipo_vinculo column
 * @method TbprofessorQuery groupByIdFormacao() Group by the id_formacao column
 * @method TbprofessorQuery groupByIdProfSit() Group by the id_prof_sit column
 * @method TbprofessorQuery groupByIdSetor() Group by the id_setor column
 * @method TbprofessorQuery groupByCoordenador() Group by the coordenador column
 * @method TbprofessorQuery groupByCreatedAt() Group by the created_at column
 * @method TbprofessorQuery groupByUpdatedAt() Group by the updated_at column
 * @method TbprofessorQuery groupByCreatedBy() Group by the created_by column
 * @method TbprofessorQuery groupByUpdatedBy() Group by the updated_by column
 *
 * @method TbprofessorQuery leftJoin($relation) Adds a LEFT JOIN clause to the query
 * @method TbprofessorQuery rightJoin($relation) Adds a RIGHT JOIN clause to the query
 * @method TbprofessorQuery innerJoin($relation) Adds a INNER JOIN clause to the query
 *
 * @method TbprofessorQuery leftJoinTbnecesespecial($relationAlias = null) Adds a LEFT JOIN clause to the query using the Tbnecesespecial relation
 * @method TbprofessorQuery rightJoinTbnecesespecial($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Tbnecesespecial relation
 * @method TbprofessorQuery innerJoinTbnecesespecial($relationAlias = null) Adds a INNER JOIN clause to the query using the Tbnecesespecial relation
 *
 * @method TbprofessorQuery leftJoinTbcurso($relationAlias = null) Adds a LEFT JOIN clause to the query using the Tbcurso relation
 * @method TbprofessorQuery rightJoinTbcurso($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Tbcurso relation
 * @method TbprofessorQuery innerJoinTbcurso($relationAlias = null) Adds a INNER JOIN clause to the query using the Tbcurso relation
 *
 * @method TbprofessorQuery leftJoinTbproftipovinculo($relationAlias = null) Adds a LEFT JOIN clause to the query using the Tbproftipovinculo relation
 * @method TbprofessorQuery rightJoinTbproftipovinculo($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Tbproftipovinculo relation
 * @method TbprofessorQuery innerJoinTbproftipovinculo($relationAlias = null) Adds a INNER JOIN clause to the query using the Tbproftipovinculo relation
 *
 * @method TbprofessorQuery leftJoinTbformacao($relationAlias = null) Adds a LEFT JOIN clause to the query using the Tbformacao relation
 * @method TbprofessorQuery rightJoinTbformacao($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Tbformacao relation
 * @method TbprofessorQuery innerJoinTbformacao($relationAlias = null) Adds a INNER JOIN clause to the query using the Tbformacao relation
 *
 * @method TbprofessorQuery leftJoinTbprofessorsituacao($relationAlias = null) Adds a LEFT JOIN clause to the query using the Tbprofessorsituacao relation
 * @method TbprofessorQuery rightJoinTbprofessorsituacao($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Tbprofessorsituacao relation
 * @method TbprofessorQuery innerJoinTbprofessorsituacao($relationAlias = null) Adds a INNER JOIN clause to the query using the Tbprofessorsituacao relation
 *
 * @method TbprofessorQuery leftJoinTbsetor($relationAlias = null) Adds a LEFT JOIN clause to the query using the Tbsetor relation
 * @method TbprofessorQuery rightJoinTbsetor($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Tbsetor relation
 * @method TbprofessorQuery innerJoinTbsetor($relationAlias = null) Adds a INNER JOIN clause to the query using the Tbsetor relation
 *
 * @method TbprofessorQuery leftJoinTbofertaRelatedByIdMatriculaProf($relationAlias = null) Adds a LEFT JOIN clause to the query using the TbofertaRelatedByIdMatriculaProf relation
 * @method TbprofessorQuery rightJoinTbofertaRelatedByIdMatriculaProf($relationAlias = null) Adds a RIGHT JOIN clause to the query using the TbofertaRelatedByIdMatriculaProf relation
 * @method TbprofessorQuery innerJoinTbofertaRelatedByIdMatriculaProf($relationAlias = null) Adds a INNER JOIN clause to the query using the TbofertaRelatedByIdMatriculaProf relation
 *
 * @method TbprofessorQuery leftJoinTbofertaRelatedByIdMatriculaProf2($relationAlias = null) Adds a LEFT JOIN clause to the query using the TbofertaRelatedByIdMatriculaProf2 relation
 * @method TbprofessorQuery rightJoinTbofertaRelatedByIdMatriculaProf2($relationAlias = null) Adds a RIGHT JOIN clause to the query using the TbofertaRelatedByIdMatriculaProf2 relation
 * @method TbprofessorQuery innerJoinTbofertaRelatedByIdMatriculaProf2($relationAlias = null) Adds a INNER JOIN clause to the query using the TbofertaRelatedByIdMatriculaProf2 relation
 *
 * @method TbprofessorQuery leftJoinTbofertacoordenador($relationAlias = null) Adds a LEFT JOIN clause to the query using the Tbofertacoordenador relation
 * @method TbprofessorQuery rightJoinTbofertacoordenador($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Tbofertacoordenador relation
 * @method TbprofessorQuery innerJoinTbofertacoordenador($relationAlias = null) Adds a INNER JOIN clause to the query using the Tbofertacoordenador relation
 *
 * @method TbprofessorQuery leftJoinTbcoordenadorcurso($relationAlias = null) Adds a LEFT JOIN clause to the query using the Tbcoordenadorcurso relation
 * @method TbprofessorQuery rightJoinTbcoordenadorcurso($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Tbcoordenadorcurso relation
 * @method TbprofessorQuery innerJoinTbcoordenadorcurso($relationAlias = null) Adds a INNER JOIN clause to the query using the Tbcoordenadorcurso relation
 *
 * @method TbprofessorQuery leftJoinTbprofessorsenha($relationAlias = null) Adds a LEFT JOIN clause to the query using the Tbprofessorsenha relation
 * @method TbprofessorQuery rightJoinTbprofessorsenha($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Tbprofessorsenha relation
 * @method TbprofessorQuery innerJoinTbprofessorsenha($relationAlias = null) Adds a INNER JOIN clause to the query using the Tbprofessorsenha relation
 *
 * @method TbprofessorQuery leftJoinTbprofessorticket($relationAlias = null) Adds a LEFT JOIN clause to the query using the Tbprofessorticket relation
 * @method TbprofessorQuery rightJoinTbprofessorticket($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Tbprofessorticket relation
 * @method TbprofessorQuery innerJoinTbprofessorticket($relationAlias = null) Adds a INNER JOIN clause to the query using the Tbprofessorticket relation
 *
 * @method TbprofessorQuery leftJoinTbturmaProfessor($relationAlias = null) Adds a LEFT JOIN clause to the query using the TbturmaProfessor relation
 * @method TbprofessorQuery rightJoinTbturmaProfessor($relationAlias = null) Adds a RIGHT JOIN clause to the query using the TbturmaProfessor relation
 * @method TbprofessorQuery innerJoinTbturmaProfessor($relationAlias = null) Adds a INNER JOIN clause to the query using the TbturmaProfessor relation
 *
 * @method Tbprofessor findOne(PropelPDO $con = null) Return the first Tbprofessor matching the query
 * @method Tbprofessor findOneOrCreate(PropelPDO $con = null) Return the first Tbprofessor matching the query, or a new Tbprofessor object populated from the query conditions when no match is found
 *
 * @method Tbprofessor findOneByIdPessoa(int $id_pessoa) Return the first Tbprofessor filtered by the id_pessoa column
 * @method Tbprofessor findOneByMatriculaProf(int $matricula_prof) Return the first Tbprofessor filtered by the matricula_prof column
 * @method Tbprofessor findOneBySiape(int $siape) Return the first Tbprofessor filtered by the siape column
 * @method Tbprofessor findOneByNome(string $nome) Return the first Tbprofessor filtered by the nome column
 * @method Tbprofessor findOneByCelular(string $celular) Return the first Tbprofessor filtered by the celular column
 * @method Tbprofessor findOneByFoneResidencial(string $fone_residencial) Return the first Tbprofessor filtered by the fone_residencial column
 * @method Tbprofessor findOneByEmail(string $email) Return the first Tbprofessor filtered by the email column
 * @method Tbprofessor findOneByFoto(resource $foto) Return the first Tbprofessor filtered by the foto column
 * @method Tbprofessor findOneByIdNecesEspecial(string $id_neces_especial) Return the first Tbprofessor filtered by the id_neces_especial column
 * @method Tbprofessor findOneByCodCurso(int $cod_curso) Return the first Tbprofessor filtered by the cod_curso column
 * @method Tbprofessor findOneByIdTipoVinculo(int $id_tipo_vinculo) Return the first Tbprofessor filtered by the id_tipo_vinculo column
 * @method Tbprofessor findOneByIdFormacao(int $id_formacao) Return the first Tbprofessor filtered by the id_formacao column
 * @method Tbprofessor findOneByIdProfSit(int $id_prof_sit) Return the first Tbprofessor filtered by the id_prof_sit column
 * @method Tbprofessor findOneByIdSetor(string $id_setor) Return the first Tbprofessor filtered by the id_setor column
 * @method Tbprofessor findOneByCoordenador(boolean $coordenador) Return the first Tbprofessor filtered by the coordenador column
 * @method Tbprofessor findOneByCreatedAt(string $created_at) Return the first Tbprofessor filtered by the created_at column
 * @method Tbprofessor findOneByUpdatedAt(string $updated_at) Return the first Tbprofessor filtered by the updated_at column
 * @method Tbprofessor findOneByCreatedBy(string $created_by) Return the first Tbprofessor filtered by the created_by column
 * @method Tbprofessor findOneByUpdatedBy(string $updated_by) Return the first Tbprofessor filtered by the updated_by column
 *
 * @method array findByIdPessoa(int $id_pessoa) Return Tbprofessor objects filtered by the id_pessoa column
 * @method array findByMatriculaProf(int $matricula_prof) Return Tbprofessor objects filtered by the matricula_prof column
 * @method array findBySiape(int $siape) Return Tbprofessor objects filtered by the siape column
 * @method array findByNome(string $nome) Return Tbprofessor objects filtered by the nome column
 * @method array findByCelular(string $celular) Return Tbprofessor objects filtered by the celular column
 * @method array findByFoneResidencial(string $fone_residencial) Return Tbprofessor objects filtered by the fone_residencial column
 * @method array findByEmail(string $email) Return Tbprofessor objects filtered by the email column
 * @method array findByFoto(resource $foto) Return Tbprofessor objects filtered by the foto column
 * @method array findByIdNecesEspecial(string $id_neces_especial) Return Tbprofessor objects filtered by the id_neces_especial column
 * @method array findByCodCurso(int $cod_curso) Return Tbprofessor objects filtered by the cod_curso column
 * @method array findByIdTipoVinculo(int $id_tipo_vinculo) Return Tbprofessor objects filtered by the id_tipo_vinculo column
 * @method array findByIdFormacao(int $id_formacao) Return Tbprofessor objects filtered by the id_formacao column
 * @method array findByIdProfSit(int $id_prof_sit) Return Tbprofessor objects filtered by the id_prof_sit column
 * @method array findByIdSetor(string $id_setor) Return Tbprofessor objects filtered by the id_setor column
 * @method array findByCoordenador(boolean $coordenador) Return Tbprofessor objects filtered by the coordenador column
 * @method array findByCreatedAt(string $created_at) Return Tbprofessor objects filtered by the created_at column
 * @method array findByUpdatedAt(string $updated_at) Return Tbprofessor objects filtered by the updated_at column
 * @method array findByCreatedBy(string $created_by) Return Tbprofessor objects filtered by the created_by column
 * @method array findByUpdatedBy(string $updated_by) Return Tbprofessor objects filtered by the updated_by column
 *
 * @package    propel.generator.lib.model.om
 */
abstract class BaseTbprofessorQuery extends ModelCriteria
{
    /**
     * Initializes internal state of BaseTbprofessorQuery object.
     *
     * @param     string $dbName The dabase name
     * @param     string $modelName The phpName of a model, e.g. 'Book'
     * @param     string $modelAlias The alias for the model in this query, e.g. 'b'
     */
    public function __construct($dbName = 'propel', $modelName = 'Tbprofessor', $modelAlias = null)
    {
        parent::__construct($dbName, $modelName, $modelAlias);
    }

    /**
     * Returns a new TbprofessorQuery object.
     *
     * @param     string $modelAlias The alias of a model in the query
     * @param     TbprofessorQuery|Criteria $criteria Optional Criteria to build the query from
     *
     * @return TbprofessorQuery
     */
    public static function create($modelAlias = null, $criteria = null)
    {
        if ($criteria instanceof TbprofessorQuery) {
            return $criteria;
        }
        $query = new TbprofessorQuery();
        if (null !== $modelAlias) {
            $query->setModelAlias($modelAlias);
        }
        if ($criteria instanceof Criteria) {
            $query->mergeWith($criteria);
        }

        return $query;
    }

    /**
     * Find object by primary key.
     * Propel uses the instance pool to skip the database if the object exists.
     * Go fast if the query is untouched.
     *
     * <code>
     * $obj  = $c->findPk(12, $con);
     * </code>
     *
     * @param mixed $key Primary key to use for the query
     * @param     PropelPDO $con an optional connection object
     *
     * @return   Tbprofessor|Tbprofessor[]|mixed the result, formatted by the current formatter
     */
    public function findPk($key, $con = null)
    {
        if ($key === null) {
            return null;
        }
        if ((null !== ($obj = TbprofessorPeer::getInstanceFromPool((string) $key))) && !$this->formatter) {
            // the object is alredy in the instance pool
            return $obj;
        }
        if ($con === null) {
            $con = Propel::getConnection(TbprofessorPeer::DATABASE_NAME, Propel::CONNECTION_READ);
        }
        $this->basePreSelect($con);
        if ($this->formatter || $this->modelAlias || $this->with || $this->select
         || $this->selectColumns || $this->asColumns || $this->selectModifiers
         || $this->map || $this->having || $this->joins) {
            return $this->findPkComplex($key, $con);
        } else {
            return $this->findPkSimple($key, $con);
        }
    }

    /**
     * Find object by primary key using raw SQL to go fast.
     * Bypass doSelect() and the object formatter by using generated code.
     *
     * @param     mixed $key Primary key to use for the query
     * @param     PropelPDO $con A connection object
     *
     * @return   Tbprofessor A model object, or null if the key is not found
     * @throws   PropelException
     */
    protected function findPkSimple($key, $con)
    {
        $sql = 'SELECT ID_PESSOA, MATRICULA_PROF, SIAPE, NOME, CELULAR, FONE_RESIDENCIAL, EMAIL, FOTO, ID_NECES_ESPECIAL, COD_CURSO, ID_TIPO_VINCULO, ID_FORMACAO, ID_PROF_SIT, ID_SETOR, COORDENADOR, CREATED_AT, UPDATED_AT, CREATED_BY, UPDATED_BY FROM tbprofessor WHERE MATRICULA_PROF = :p0';
        try {
            $stmt = $con->prepare($sql);
            $stmt->bindValue(':p0', $key, PDO::PARAM_INT);
            $stmt->execute();
        } catch (Exception $e) {
            Propel::log($e->getMessage(), Propel::LOG_ERR);
            throw new PropelException(sprintf('Unable to execute SELECT statement [%s]', $sql), $e);
        }
        $obj = null;
        if ($row = $stmt->fetch(PDO::FETCH_NUM)) {
            $obj = new Tbprofessor();
            $obj->hydrate($row);
            TbprofessorPeer::addInstanceToPool($obj, (string) $key);
        }
        $stmt->closeCursor();

        return $obj;
    }

    /**
     * Find object by primary key.
     *
     * @param     mixed $key Primary key to use for the query
     * @param     PropelPDO $con A connection object
     *
     * @return Tbprofessor|Tbprofessor[]|mixed the result, formatted by the current formatter
     */
    protected function findPkComplex($key, $con)
    {
        // As the query uses a PK condition, no limit(1) is necessary.
        $criteria = $this->isKeepQuery() ? clone $this : $this;
        $stmt = $criteria
            ->filterByPrimaryKey($key)
            ->doSelect($con);

        return $criteria->getFormatter()->init($criteria)->formatOne($stmt);
    }

    /**
     * Find objects by primary key
     * <code>
     * $objs = $c->findPks(array(12, 56, 832), $con);
     * </code>
     * @param     array $keys Primary keys to use for the query
     * @param     PropelPDO $con an optional connection object
     *
     * @return PropelObjectCollection|Tbprofessor[]|mixed the list of results, formatted by the current formatter
     */
    public function findPks($keys, $con = null)
    {
        if ($con === null) {
            $con = Propel::getConnection($this->getDbName(), Propel::CONNECTION_READ);
        }
        $this->basePreSelect($con);
        $criteria = $this->isKeepQuery() ? clone $this : $this;
        $stmt = $criteria
            ->filterByPrimaryKeys($keys)
            ->doSelect($con);

        return $criteria->getFormatter()->init($criteria)->format($stmt);
    }

    /**
     * Filter the query by primary key
     *
     * @param     mixed $key Primary key to use for the query
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByPrimaryKey($key)
    {

        return $this->addUsingAlias(TbprofessorPeer::MATRICULA_PROF, $key, Criteria::EQUAL);
    }

    /**
     * Filter the query by a list of primary keys
     *
     * @param     array $keys The list of primary key to use for the query
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByPrimaryKeys($keys)
    {

        return $this->addUsingAlias(TbprofessorPeer::MATRICULA_PROF, $keys, Criteria::IN);
    }

    /**
     * Filter the query on the id_pessoa column
     *
     * Example usage:
     * <code>
     * $query->filterByIdPessoa(1234); // WHERE id_pessoa = 1234
     * $query->filterByIdPessoa(array(12, 34)); // WHERE id_pessoa IN (12, 34)
     * $query->filterByIdPessoa(array('min' => 12)); // WHERE id_pessoa > 12
     * </code>
     *
     * @param     mixed $idPessoa The value to use as filter.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByIdPessoa($idPessoa = null, $comparison = null)
    {
        if (is_array($idPessoa)) {
            $useMinMax = false;
            if (isset($idPessoa['min'])) {
                $this->addUsingAlias(TbprofessorPeer::ID_PESSOA, $idPessoa['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($idPessoa['max'])) {
                $this->addUsingAlias(TbprofessorPeer::ID_PESSOA, $idPessoa['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::ID_PESSOA, $idPessoa, $comparison);
    }

    /**
     * Filter the query on the matricula_prof column
     *
     * Example usage:
     * <code>
     * $query->filterByMatriculaProf(1234); // WHERE matricula_prof = 1234
     * $query->filterByMatriculaProf(array(12, 34)); // WHERE matricula_prof IN (12, 34)
     * $query->filterByMatriculaProf(array('min' => 12)); // WHERE matricula_prof > 12
     * </code>
     *
     * @param     mixed $matriculaProf The value to use as filter.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByMatriculaProf($matriculaProf = null, $comparison = null)
    {
        if (is_array($matriculaProf) && null === $comparison) {
            $comparison = Criteria::IN;
        }

        return $this->addUsingAlias(TbprofessorPeer::MATRICULA_PROF, $matriculaProf, $comparison);
    }

    /**
     * Filter the query on the siape column
     *
     * Example usage:
     * <code>
     * $query->filterBySiape(1234); // WHERE siape = 1234
     * $query->filterBySiape(array(12, 34)); // WHERE siape IN (12, 34)
     * $query->filterBySiape(array('min' => 12)); // WHERE siape > 12
     * </code>
     *
     * @param     mixed $siape The value to use as filter.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterBySiape($siape = null, $comparison = null)
    {
        if (is_array($siape)) {
            $useMinMax = false;
            if (isset($siape['min'])) {
                $this->addUsingAlias(TbprofessorPeer::SIAPE, $siape['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($siape['max'])) {
                $this->addUsingAlias(TbprofessorPeer::SIAPE, $siape['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::SIAPE, $siape, $comparison);
    }

    /**
     * Filter the query on the nome column
     *
     * Example usage:
     * <code>
     * $query->filterByNome('fooValue');   // WHERE nome = 'fooValue'
     * $query->filterByNome('%fooValue%'); // WHERE nome LIKE '%fooValue%'
     * </code>
     *
     * @param     string $nome The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByNome($nome = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($nome)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $nome)) {
                $nome = str_replace('*', '%', $nome);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::NOME, $nome, $comparison);
    }

    /**
     * Filter the query on the celular column
     *
     * Example usage:
     * <code>
     * $query->filterByCelular('fooValue');   // WHERE celular = 'fooValue'
     * $query->filterByCelular('%fooValue%'); // WHERE celular LIKE '%fooValue%'
     * </code>
     *
     * @param     string $celular The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByCelular($celular = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($celular)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $celular)) {
                $celular = str_replace('*', '%', $celular);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::CELULAR, $celular, $comparison);
    }

    /**
     * Filter the query on the fone_residencial column
     *
     * Example usage:
     * <code>
     * $query->filterByFoneResidencial('fooValue');   // WHERE fone_residencial = 'fooValue'
     * $query->filterByFoneResidencial('%fooValue%'); // WHERE fone_residencial LIKE '%fooValue%'
     * </code>
     *
     * @param     string $foneResidencial The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByFoneResidencial($foneResidencial = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($foneResidencial)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $foneResidencial)) {
                $foneResidencial = str_replace('*', '%', $foneResidencial);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::FONE_RESIDENCIAL, $foneResidencial, $comparison);
    }

    /**
     * Filter the query on the email column
     *
     * Example usage:
     * <code>
     * $query->filterByEmail('fooValue');   // WHERE email = 'fooValue'
     * $query->filterByEmail('%fooValue%'); // WHERE email LIKE '%fooValue%'
     * </code>
     *
     * @param     string $email The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByEmail($email = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($email)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $email)) {
                $email = str_replace('*', '%', $email);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::EMAIL, $email, $comparison);
    }

    /**
     * Filter the query on the foto column
     *
     * @param     mixed $foto The value to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByFoto($foto = null, $comparison = null)
    {

        return $this->addUsingAlias(TbprofessorPeer::FOTO, $foto, $comparison);
    }

    /**
     * Filter the query on the id_neces_especial column
     *
     * Example usage:
     * <code>
     * $query->filterByIdNecesEspecial('fooValue');   // WHERE id_neces_especial = 'fooValue'
     * $query->filterByIdNecesEspecial('%fooValue%'); // WHERE id_neces_especial LIKE '%fooValue%'
     * </code>
     *
     * @param     string $idNecesEspecial The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByIdNecesEspecial($idNecesEspecial = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($idNecesEspecial)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $idNecesEspecial)) {
                $idNecesEspecial = str_replace('*', '%', $idNecesEspecial);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::ID_NECES_ESPECIAL, $idNecesEspecial, $comparison);
    }

    /**
     * Filter the query on the cod_curso column
     *
     * Example usage:
     * <code>
     * $query->filterByCodCurso(1234); // WHERE cod_curso = 1234
     * $query->filterByCodCurso(array(12, 34)); // WHERE cod_curso IN (12, 34)
     * $query->filterByCodCurso(array('min' => 12)); // WHERE cod_curso > 12
     * </code>
     *
     * @see       filterByTbcurso()
     *
     * @param     mixed $codCurso The value to use as filter.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByCodCurso($codCurso = null, $comparison = null)
    {
        if (is_array($codCurso)) {
            $useMinMax = false;
            if (isset($codCurso['min'])) {
                $this->addUsingAlias(TbprofessorPeer::COD_CURSO, $codCurso['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($codCurso['max'])) {
                $this->addUsingAlias(TbprofessorPeer::COD_CURSO, $codCurso['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::COD_CURSO, $codCurso, $comparison);
    }

    /**
     * Filter the query on the id_tipo_vinculo column
     *
     * Example usage:
     * <code>
     * $query->filterByIdTipoVinculo(1234); // WHERE id_tipo_vinculo = 1234
     * $query->filterByIdTipoVinculo(array(12, 34)); // WHERE id_tipo_vinculo IN (12, 34)
     * $query->filterByIdTipoVinculo(array('min' => 12)); // WHERE id_tipo_vinculo > 12
     * </code>
     *
     * @see       filterByTbproftipovinculo()
     *
     * @param     mixed $idTipoVinculo The value to use as filter.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByIdTipoVinculo($idTipoVinculo = null, $comparison = null)
    {
        if (is_array($idTipoVinculo)) {
            $useMinMax = false;
            if (isset($idTipoVinculo['min'])) {
                $this->addUsingAlias(TbprofessorPeer::ID_TIPO_VINCULO, $idTipoVinculo['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($idTipoVinculo['max'])) {
                $this->addUsingAlias(TbprofessorPeer::ID_TIPO_VINCULO, $idTipoVinculo['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::ID_TIPO_VINCULO, $idTipoVinculo, $comparison);
    }

    /**
     * Filter the query on the id_formacao column
     *
     * Example usage:
     * <code>
     * $query->filterByIdFormacao(1234); // WHERE id_formacao = 1234
     * $query->filterByIdFormacao(array(12, 34)); // WHERE id_formacao IN (12, 34)
     * $query->filterByIdFormacao(array('min' => 12)); // WHERE id_formacao > 12
     * </code>
     *
     * @see       filterByTbformacao()
     *
     * @param     mixed $idFormacao The value to use as filter.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByIdFormacao($idFormacao = null, $comparison = null)
    {
        if (is_array($idFormacao)) {
            $useMinMax = false;
            if (isset($idFormacao['min'])) {
                $this->addUsingAlias(TbprofessorPeer::ID_FORMACAO, $idFormacao['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($idFormacao['max'])) {
                $this->addUsingAlias(TbprofessorPeer::ID_FORMACAO, $idFormacao['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::ID_FORMACAO, $idFormacao, $comparison);
    }

    /**
     * Filter the query on the id_prof_sit column
     *
     * Example usage:
     * <code>
     * $query->filterByIdProfSit(1234); // WHERE id_prof_sit = 1234
     * $query->filterByIdProfSit(array(12, 34)); // WHERE id_prof_sit IN (12, 34)
     * $query->filterByIdProfSit(array('min' => 12)); // WHERE id_prof_sit > 12
     * </code>
     *
     * @see       filterByTbprofessorsituacao()
     *
     * @param     mixed $idProfSit The value to use as filter.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByIdProfSit($idProfSit = null, $comparison = null)
    {
        if (is_array($idProfSit)) {
            $useMinMax = false;
            if (isset($idProfSit['min'])) {
                $this->addUsingAlias(TbprofessorPeer::ID_PROF_SIT, $idProfSit['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($idProfSit['max'])) {
                $this->addUsingAlias(TbprofessorPeer::ID_PROF_SIT, $idProfSit['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::ID_PROF_SIT, $idProfSit, $comparison);
    }

    /**
     * Filter the query on the id_setor column
     *
     * Example usage:
     * <code>
     * $query->filterByIdSetor('fooValue');   // WHERE id_setor = 'fooValue'
     * $query->filterByIdSetor('%fooValue%'); // WHERE id_setor LIKE '%fooValue%'
     * </code>
     *
     * @param     string $idSetor The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByIdSetor($idSetor = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($idSetor)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $idSetor)) {
                $idSetor = str_replace('*', '%', $idSetor);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::ID_SETOR, $idSetor, $comparison);
    }

    /**
     * Filter the query on the coordenador column
     *
     * Example usage:
     * <code>
     * $query->filterByCoordenador(true); // WHERE coordenador = true
     * $query->filterByCoordenador('yes'); // WHERE coordenador = true
     * </code>
     *
     * @param     boolean|string $coordenador The value to use as filter.
     *              Non-boolean arguments are converted using the following rules:
     *                * 1, '1', 'true',  'on',  and 'yes' are converted to boolean true
     *                * 0, '0', 'false', 'off', and 'no'  are converted to boolean false
     *              Check on string values is case insensitive (so 'FaLsE' is seen as 'false').
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByCoordenador($coordenador = null, $comparison = null)
    {
        if (is_string($coordenador)) {
            $coordenador = in_array(strtolower($coordenador), array('false', 'off', '-', 'no', 'n', '0', '')) ? false : true;
        }

        return $this->addUsingAlias(TbprofessorPeer::COORDENADOR, $coordenador, $comparison);
    }

    /**
     * Filter the query on the created_at column
     *
     * Example usage:
     * <code>
     * $query->filterByCreatedAt('2011-03-14'); // WHERE created_at = '2011-03-14'
     * $query->filterByCreatedAt('now'); // WHERE created_at = '2011-03-14'
     * $query->filterByCreatedAt(array('max' => 'yesterday')); // WHERE created_at > '2011-03-13'
     * </code>
     *
     * @param     mixed $createdAt The value to use as filter.
     *              Values can be integers (unix timestamps), DateTime objects, or strings.
     *              Empty strings are treated as NULL.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByCreatedAt($createdAt = null, $comparison = null)
    {
        if (is_array($createdAt)) {
            $useMinMax = false;
            if (isset($createdAt['min'])) {
                $this->addUsingAlias(TbprofessorPeer::CREATED_AT, $createdAt['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($createdAt['max'])) {
                $this->addUsingAlias(TbprofessorPeer::CREATED_AT, $createdAt['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::CREATED_AT, $createdAt, $comparison);
    }

    /**
     * Filter the query on the updated_at column
     *
     * Example usage:
     * <code>
     * $query->filterByUpdatedAt('2011-03-14'); // WHERE updated_at = '2011-03-14'
     * $query->filterByUpdatedAt('now'); // WHERE updated_at = '2011-03-14'
     * $query->filterByUpdatedAt(array('max' => 'yesterday')); // WHERE updated_at > '2011-03-13'
     * </code>
     *
     * @param     mixed $updatedAt The value to use as filter.
     *              Values can be integers (unix timestamps), DateTime objects, or strings.
     *              Empty strings are treated as NULL.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByUpdatedAt($updatedAt = null, $comparison = null)
    {
        if (is_array($updatedAt)) {
            $useMinMax = false;
            if (isset($updatedAt['min'])) {
                $this->addUsingAlias(TbprofessorPeer::UPDATED_AT, $updatedAt['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($updatedAt['max'])) {
                $this->addUsingAlias(TbprofessorPeer::UPDATED_AT, $updatedAt['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::UPDATED_AT, $updatedAt, $comparison);
    }

    /**
     * Filter the query on the created_by column
     *
     * Example usage:
     * <code>
     * $query->filterByCreatedBy('fooValue');   // WHERE created_by = 'fooValue'
     * $query->filterByCreatedBy('%fooValue%'); // WHERE created_by LIKE '%fooValue%'
     * </code>
     *
     * @param     string $createdBy The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByCreatedBy($createdBy = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($createdBy)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $createdBy)) {
                $createdBy = str_replace('*', '%', $createdBy);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::CREATED_BY, $createdBy, $comparison);
    }

    /**
     * Filter the query on the updated_by column
     *
     * Example usage:
     * <code>
     * $query->filterByUpdatedBy('fooValue');   // WHERE updated_by = 'fooValue'
     * $query->filterByUpdatedBy('%fooValue%'); // WHERE updated_by LIKE '%fooValue%'
     * </code>
     *
     * @param     string $updatedBy The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function filterByUpdatedBy($updatedBy = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($updatedBy)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $updatedBy)) {
                $updatedBy = str_replace('*', '%', $updatedBy);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(TbprofessorPeer::UPDATED_BY, $updatedBy, $comparison);
    }

    /**
     * Filter the query by a related Tbnecesespecial object
     *
     * @param   Tbnecesespecial|PropelObjectCollection $tbnecesespecial The related object(s) to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   TbprofessorQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByTbnecesespecial($tbnecesespecial, $comparison = null)
    {
        if ($tbnecesespecial instanceof Tbnecesespecial) {
            return $this
                ->addUsingAlias(TbprofessorPeer::ID_NECES_ESPECIAL, $tbnecesespecial->getIdNecesEspecial(), $comparison);
        } elseif ($tbnecesespecial instanceof PropelObjectCollection) {
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }

            return $this
                ->addUsingAlias(TbprofessorPeer::ID_NECES_ESPECIAL, $tbnecesespecial->toKeyValue('PrimaryKey', 'IdNecesEspecial'), $comparison);
        } else {
            throw new PropelException('filterByTbnecesespecial() only accepts arguments of type Tbnecesespecial or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Tbnecesespecial relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function joinTbnecesespecial($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Tbnecesespecial');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Tbnecesespecial');
        }

        return $this;
    }

    /**
     * Use the Tbnecesespecial relation Tbnecesespecial object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   TbnecesespecialQuery A secondary query class using the current class as primary query
     */
    public function useTbnecesespecialQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinTbnecesespecial($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Tbnecesespecial', 'TbnecesespecialQuery');
    }

    /**
     * Filter the query by a related Tbcurso object
     *
     * @param   Tbcurso|PropelObjectCollection $tbcurso The related object(s) to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   TbprofessorQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByTbcurso($tbcurso, $comparison = null)
    {
        if ($tbcurso instanceof Tbcurso) {
            return $this
                ->addUsingAlias(TbprofessorPeer::COD_CURSO, $tbcurso->getCodCurso(), $comparison);
        } elseif ($tbcurso instanceof PropelObjectCollection) {
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }

            return $this
                ->addUsingAlias(TbprofessorPeer::COD_CURSO, $tbcurso->toKeyValue('PrimaryKey', 'CodCurso'), $comparison);
        } else {
            throw new PropelException('filterByTbcurso() only accepts arguments of type Tbcurso or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Tbcurso relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function joinTbcurso($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Tbcurso');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Tbcurso');
        }

        return $this;
    }

    /**
     * Use the Tbcurso relation Tbcurso object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   TbcursoQuery A secondary query class using the current class as primary query
     */
    public function useTbcursoQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinTbcurso($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Tbcurso', 'TbcursoQuery');
    }

    /**
     * Filter the query by a related Tbproftipovinculo object
     *
     * @param   Tbproftipovinculo|PropelObjectCollection $tbproftipovinculo The related object(s) to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   TbprofessorQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByTbproftipovinculo($tbproftipovinculo, $comparison = null)
    {
        if ($tbproftipovinculo instanceof Tbproftipovinculo) {
            return $this
                ->addUsingAlias(TbprofessorPeer::ID_TIPO_VINCULO, $tbproftipovinculo->getIdTipoVinculo(), $comparison);
        } elseif ($tbproftipovinculo instanceof PropelObjectCollection) {
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }

            return $this
                ->addUsingAlias(TbprofessorPeer::ID_TIPO_VINCULO, $tbproftipovinculo->toKeyValue('PrimaryKey', 'IdTipoVinculo'), $comparison);
        } else {
            throw new PropelException('filterByTbproftipovinculo() only accepts arguments of type Tbproftipovinculo or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Tbproftipovinculo relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function joinTbproftipovinculo($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Tbproftipovinculo');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Tbproftipovinculo');
        }

        return $this;
    }

    /**
     * Use the Tbproftipovinculo relation Tbproftipovinculo object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   TbproftipovinculoQuery A secondary query class using the current class as primary query
     */
    public function useTbproftipovinculoQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinTbproftipovinculo($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Tbproftipovinculo', 'TbproftipovinculoQuery');
    }

    /**
     * Filter the query by a related Tbformacao object
     *
     * @param   Tbformacao|PropelObjectCollection $tbformacao The related object(s) to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   TbprofessorQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByTbformacao($tbformacao, $comparison = null)
    {
        if ($tbformacao instanceof Tbformacao) {
            return $this
                ->addUsingAlias(TbprofessorPeer::ID_FORMACAO, $tbformacao->getIdFormacao(), $comparison);
        } elseif ($tbformacao instanceof PropelObjectCollection) {
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }

            return $this
                ->addUsingAlias(TbprofessorPeer::ID_FORMACAO, $tbformacao->toKeyValue('PrimaryKey', 'IdFormacao'), $comparison);
        } else {
            throw new PropelException('filterByTbformacao() only accepts arguments of type Tbformacao or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Tbformacao relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function joinTbformacao($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Tbformacao');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Tbformacao');
        }

        return $this;
    }

    /**
     * Use the Tbformacao relation Tbformacao object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   TbformacaoQuery A secondary query class using the current class as primary query
     */
    public function useTbformacaoQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinTbformacao($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Tbformacao', 'TbformacaoQuery');
    }

    /**
     * Filter the query by a related Tbprofessorsituacao object
     *
     * @param   Tbprofessorsituacao|PropelObjectCollection $tbprofessorsituacao The related object(s) to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   TbprofessorQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByTbprofessorsituacao($tbprofessorsituacao, $comparison = null)
    {
        if ($tbprofessorsituacao instanceof Tbprofessorsituacao) {
            return $this
                ->addUsingAlias(TbprofessorPeer::ID_PROF_SIT, $tbprofessorsituacao->getIdSituacao(), $comparison);
        } elseif ($tbprofessorsituacao instanceof PropelObjectCollection) {
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }

            return $this
                ->addUsingAlias(TbprofessorPeer::ID_PROF_SIT, $tbprofessorsituacao->toKeyValue('PrimaryKey', 'IdSituacao'), $comparison);
        } else {
            throw new PropelException('filterByTbprofessorsituacao() only accepts arguments of type Tbprofessorsituacao or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Tbprofessorsituacao relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function joinTbprofessorsituacao($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Tbprofessorsituacao');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Tbprofessorsituacao');
        }

        return $this;
    }

    /**
     * Use the Tbprofessorsituacao relation Tbprofessorsituacao object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   TbprofessorsituacaoQuery A secondary query class using the current class as primary query
     */
    public function useTbprofessorsituacaoQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinTbprofessorsituacao($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Tbprofessorsituacao', 'TbprofessorsituacaoQuery');
    }

    /**
     * Filter the query by a related Tbsetor object
     *
     * @param   Tbsetor|PropelObjectCollection $tbsetor The related object(s) to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   TbprofessorQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByTbsetor($tbsetor, $comparison = null)
    {
        if ($tbsetor instanceof Tbsetor) {
            return $this
                ->addUsingAlias(TbprofessorPeer::ID_SETOR, $tbsetor->getIdSetor(), $comparison);
        } elseif ($tbsetor instanceof PropelObjectCollection) {
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }

            return $this
                ->addUsingAlias(TbprofessorPeer::ID_SETOR, $tbsetor->toKeyValue('PrimaryKey', 'IdSetor'), $comparison);
        } else {
            throw new PropelException('filterByTbsetor() only accepts arguments of type Tbsetor or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Tbsetor relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function joinTbsetor($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Tbsetor');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Tbsetor');
        }

        return $this;
    }

    /**
     * Use the Tbsetor relation Tbsetor object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   TbsetorQuery A secondary query class using the current class as primary query
     */
    public function useTbsetorQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinTbsetor($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Tbsetor', 'TbsetorQuery');
    }

    /**
     * Filter the query by a related Tboferta object
     *
     * @param   Tboferta|PropelObjectCollection $tboferta  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   TbprofessorQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByTbofertaRelatedByIdMatriculaProf($tboferta, $comparison = null)
    {
        if ($tboferta instanceof Tboferta) {
            return $this
                ->addUsingAlias(TbprofessorPeer::MATRICULA_PROF, $tboferta->getIdMatriculaProf(), $comparison);
        } elseif ($tboferta instanceof PropelObjectCollection) {
            return $this
                ->useTbofertaRelatedByIdMatriculaProfQuery()
                ->filterByPrimaryKeys($tboferta->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByTbofertaRelatedByIdMatriculaProf() only accepts arguments of type Tboferta or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the TbofertaRelatedByIdMatriculaProf relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function joinTbofertaRelatedByIdMatriculaProf($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('TbofertaRelatedByIdMatriculaProf');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'TbofertaRelatedByIdMatriculaProf');
        }

        return $this;
    }

    /**
     * Use the TbofertaRelatedByIdMatriculaProf relation Tboferta object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   TbofertaQuery A secondary query class using the current class as primary query
     */
    public function useTbofertaRelatedByIdMatriculaProfQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinTbofertaRelatedByIdMatriculaProf($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'TbofertaRelatedByIdMatriculaProf', 'TbofertaQuery');
    }

    /**
     * Filter the query by a related Tboferta object
     *
     * @param   Tboferta|PropelObjectCollection $tboferta  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   TbprofessorQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByTbofertaRelatedByIdMatriculaProf2($tboferta, $comparison = null)
    {
        if ($tboferta instanceof Tboferta) {
            return $this
                ->addUsingAlias(TbprofessorPeer::MATRICULA_PROF, $tboferta->getIdMatriculaProf2(), $comparison);
        } elseif ($tboferta instanceof PropelObjectCollection) {
            return $this
                ->useTbofertaRelatedByIdMatriculaProf2Query()
                ->filterByPrimaryKeys($tboferta->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByTbofertaRelatedByIdMatriculaProf2() only accepts arguments of type Tboferta or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the TbofertaRelatedByIdMatriculaProf2 relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function joinTbofertaRelatedByIdMatriculaProf2($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('TbofertaRelatedByIdMatriculaProf2');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'TbofertaRelatedByIdMatriculaProf2');
        }

        return $this;
    }

    /**
     * Use the TbofertaRelatedByIdMatriculaProf2 relation Tboferta object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   TbofertaQuery A secondary query class using the current class as primary query
     */
    public function useTbofertaRelatedByIdMatriculaProf2Query($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinTbofertaRelatedByIdMatriculaProf2($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'TbofertaRelatedByIdMatriculaProf2', 'TbofertaQuery');
    }

    /**
     * Filter the query by a related Tbofertacoordenador object
     *
     * @param   Tbofertacoordenador|PropelObjectCollection $tbofertacoordenador  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   TbprofessorQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByTbofertacoordenador($tbofertacoordenador, $comparison = null)
    {
        if ($tbofertacoordenador instanceof Tbofertacoordenador) {
            return $this
                ->addUsingAlias(TbprofessorPeer::MATRICULA_PROF, $tbofertacoordenador->getMatriculaProf(), $comparison);
        } elseif ($tbofertacoordenador instanceof PropelObjectCollection) {
            return $this
                ->useTbofertacoordenadorQuery()
                ->filterByPrimaryKeys($tbofertacoordenador->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByTbofertacoordenador() only accepts arguments of type Tbofertacoordenador or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Tbofertacoordenador relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function joinTbofertacoordenador($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Tbofertacoordenador');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Tbofertacoordenador');
        }

        return $this;
    }

    /**
     * Use the Tbofertacoordenador relation Tbofertacoordenador object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   TbofertacoordenadorQuery A secondary query class using the current class as primary query
     */
    public function useTbofertacoordenadorQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinTbofertacoordenador($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Tbofertacoordenador', 'TbofertacoordenadorQuery');
    }

    /**
     * Filter the query by a related Tbcoordenadorcurso object
     *
     * @param   Tbcoordenadorcurso|PropelObjectCollection $tbcoordenadorcurso  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   TbprofessorQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByTbcoordenadorcurso($tbcoordenadorcurso, $comparison = null)
    {
        if ($tbcoordenadorcurso instanceof Tbcoordenadorcurso) {
            return $this
                ->addUsingAlias(TbprofessorPeer::MATRICULA_PROF, $tbcoordenadorcurso->getMatriculaProf(), $comparison);
        } elseif ($tbcoordenadorcurso instanceof PropelObjectCollection) {
            return $this
                ->useTbcoordenadorcursoQuery()
                ->filterByPrimaryKeys($tbcoordenadorcurso->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByTbcoordenadorcurso() only accepts arguments of type Tbcoordenadorcurso or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Tbcoordenadorcurso relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function joinTbcoordenadorcurso($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Tbcoordenadorcurso');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Tbcoordenadorcurso');
        }

        return $this;
    }

    /**
     * Use the Tbcoordenadorcurso relation Tbcoordenadorcurso object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   TbcoordenadorcursoQuery A secondary query class using the current class as primary query
     */
    public function useTbcoordenadorcursoQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinTbcoordenadorcurso($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Tbcoordenadorcurso', 'TbcoordenadorcursoQuery');
    }

    /**
     * Filter the query by a related Tbprofessorsenha object
     *
     * @param   Tbprofessorsenha|PropelObjectCollection $tbprofessorsenha  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   TbprofessorQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByTbprofessorsenha($tbprofessorsenha, $comparison = null)
    {
        if ($tbprofessorsenha instanceof Tbprofessorsenha) {
            return $this
                ->addUsingAlias(TbprofessorPeer::MATRICULA_PROF, $tbprofessorsenha->getMatriculaProf(), $comparison);
        } elseif ($tbprofessorsenha instanceof PropelObjectCollection) {
            return $this
                ->useTbprofessorsenhaQuery()
                ->filterByPrimaryKeys($tbprofessorsenha->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByTbprofessorsenha() only accepts arguments of type Tbprofessorsenha or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Tbprofessorsenha relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function joinTbprofessorsenha($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Tbprofessorsenha');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Tbprofessorsenha');
        }

        return $this;
    }

    /**
     * Use the Tbprofessorsenha relation Tbprofessorsenha object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   TbprofessorsenhaQuery A secondary query class using the current class as primary query
     */
    public function useTbprofessorsenhaQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinTbprofessorsenha($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Tbprofessorsenha', 'TbprofessorsenhaQuery');
    }

    /**
     * Filter the query by a related Tbprofessorticket object
     *
     * @param   Tbprofessorticket|PropelObjectCollection $tbprofessorticket  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   TbprofessorQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByTbprofessorticket($tbprofessorticket, $comparison = null)
    {
        if ($tbprofessorticket instanceof Tbprofessorticket) {
            return $this
                ->addUsingAlias(TbprofessorPeer::MATRICULA_PROF, $tbprofessorticket->getMatriculaProf(), $comparison);
        } elseif ($tbprofessorticket instanceof PropelObjectCollection) {
            return $this
                ->useTbprofessorticketQuery()
                ->filterByPrimaryKeys($tbprofessorticket->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByTbprofessorticket() only accepts arguments of type Tbprofessorticket or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the Tbprofessorticket relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function joinTbprofessorticket($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('Tbprofessorticket');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'Tbprofessorticket');
        }

        return $this;
    }

    /**
     * Use the Tbprofessorticket relation Tbprofessorticket object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   TbprofessorticketQuery A secondary query class using the current class as primary query
     */
    public function useTbprofessorticketQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->joinTbprofessorticket($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'Tbprofessorticket', 'TbprofessorticketQuery');
    }

    /**
     * Filter the query by a related TbturmaProfessor object
     *
     * @param   TbturmaProfessor|PropelObjectCollection $tbturmaProfessor  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   TbprofessorQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterByTbturmaProfessor($tbturmaProfessor, $comparison = null)
    {
        if ($tbturmaProfessor instanceof TbturmaProfessor) {
            return $this
                ->addUsingAlias(TbprofessorPeer::MATRICULA_PROF, $tbturmaProfessor->getMatriculaProf(), $comparison);
        } elseif ($tbturmaProfessor instanceof PropelObjectCollection) {
            return $this
                ->useTbturmaProfessorQuery()
                ->filterByPrimaryKeys($tbturmaProfessor->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterByTbturmaProfessor() only accepts arguments of type TbturmaProfessor or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the TbturmaProfessor relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function joinTbturmaProfessor($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('TbturmaProfessor');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'TbturmaProfessor');
        }

        return $this;
    }

    /**
     * Use the TbturmaProfessor relation TbturmaProfessor object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   TbturmaProfessorQuery A secondary query class using the current class as primary query
     */
    public function useTbturmaProfessorQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->joinTbturmaProfessor($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'TbturmaProfessor', 'TbturmaProfessorQuery');
    }

    /**
     * Exclude object from result
     *
     * @param   Tbprofessor $tbprofessor Object to remove from the list of results
     *
     * @return TbprofessorQuery The current query, for fluid interface
     */
    public function prune($tbprofessor = null)
    {
        if ($tbprofessor) {
            $this->addUsingAlias(TbprofessorPeer::MATRICULA_PROF, $tbprofessor->getMatriculaProf(), Criteria::NOT_EQUAL);
        }

        return $this;
    }

}
